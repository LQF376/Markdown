# 现代C++11

参考文献

- 现代C++教程：高速上手C++11/14/17

## nullptr

传统C++通常将 NULL 和 0 视为同一种东西，这取决于编译器的实现，有的编译器将NULL定义为 ((void *)0)，有些直接定义为0

C++不允许将 void* 隐式转换到其他类型【不同于C语言】

C++11引入 nullptr 关键字来区分空指针和0；nullptr的类型为 nullprt_t，能够隐式的转化为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较

## constexpr

C++11 提供 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式

```c++
#define LEN 10

constexpr int len_foo_constexpr(){
	return 5;
}

const int len = 1;		// const 常量，非常量表达式【注意区别】
constexpr int len_constexpr = 1;

char arr_1[LEN];		// 合法
char arr_2[len_foo_constexpr()];		// 合法
char arr_3[len];	// 可能非法（看编译器优化）
char arr_4[len_constexpr];	// 合法
```

从C++14开始，constexpr函数可以在内部使用局部变量、循环和分支等简单语句【C++11会报错】

## if/switch 变量声明

传统C++中，变量的声明能够在 for 语句内声明一个临时变量 int，但始终没法在 if 和 switch 语句中声明一个临时的变量，C++17取消了这一限制

```c++
// 将临时变量放到 if 语句内
if(const std::vector<int>::iterator it = std::find(vec.begin(), vec.end(), 3); it != vec.end()){
	*it = 4;
}
```

## 初始化列表

C++11 把初始化列表的概念绑定到了类型上，并将其称为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表

```c++
#include <initializer_list>
#include <vector>

class MagicFoo{
public:
    std::vector<int> vec;
    MagicFoo(std::initializer_list<int> list){
        for(std::initializer_list<int>::iterator it = list.begin();
           it != list.end(); it++){
            vec.push_back(*it);
        }
    }
};

MagicFoo magicFoo = {1, 2, 3, 4, 5};	// 初始化列表构造函数
```

初始化列表除了用在对象构造上，还能将其作为普通函数的形参

```c++
public:
	void foo(std::initializer_list<int> list){
		// do something
	}

magicFoo.foo({6, 7, 8, 9});
```

## 结构化绑定【元组】

C++11 新增 std::tuple 容器用于构造一个元组，来攘括多个返回值，C++11/14 并没有提供一种方法直接从元组中拿到并定义元组中的元素，需要使用 `std::tie` 对元组进行拆包，依然要求需要清楚这个元组包含多少个对象、对象什么类型

C++17完善了这个定义：

```c++
#include <string>
#include <tuple>

std::tuple<int, double, std::string> f() {
	return std::make_tuple(1, 2.3, "456");
}

auto [x, y, z] = f();
std::cout << x << y << z << std::endl;
```

## 类型推导 ` auto ` 和 `  decltype`

### auto

```c++
// 迭代器
std::initializer_list<int> list;

auto it = list.begin();

auto i = 5;              	// i 被推导为 int
auto arr = new auto(10); 	// arr 被推导为 int *
```

auto 不能用于函数传参；auto不能用于推导数组类型

```c++
// error
int add(auto a, auto b){
	// ...
}

auto arr2[10] = arr;		// error
```

### decltype

计算某个表达式的类型

```c++
auto x = 1;
auto y = 2;
decltype(x + y) z;
```

配合 ` std::is_same<T, U>` 实现判断两个类型是否相等

```c++
bool flag = std::is_same<decltype(z), int>::value;
```

### 尾返回类型推导

使用模板函数时，无法确认返回值类型，利用 `  auto`将返回类型后置

```c++
template<typename T, typename U>
auto add(T x, U y) -> decltype(x+y){
	return x + y;
}

auto w = add<int, double>(1, 2.3);
```

C++14开始是可以让普通函数具备返回值推导

```c++
// C++14以后合法
template<typename T, typename U>
auto add(T x, U y){
	return x + y;
}
```

### ` decltype(auto) `

C++14提出 ` decltype(auto) `主要用于对转发函数或封装的返回类型进行推导

```c++
std::string  lookup1();
std::string& lookup2();

// C++11
std::string look_up_a_string_1() {
    return lookup1();
}
std::string& look_up_a_string_2() {
    return lookup2();
}

// C++14
decltype(auto) look_up_a_string_1() {
    return lookup1();
}
decltype(auto) look_up_a_string_2() {
    return lookup2();
}
```

## 区间 for 迭代

```c++
vector<int> vec = { 1, 2, 3, 4, 5 };

for(auto each:vec)
    cout << each << endl;		// read only

for(auto &each:vec)
    each++;		// writeable
```



## 委托构造【C++11】

使得在同一个类中一个构造函数调用另一个构造函数，起到简化代码的目的

```c++
class Base {
public:
	Base() {
		value1 = 1;
	}
	Base(int value) : Base() {
		value2 = value;
	}
private:
	int value1;
	int value2;
};
```

## 继承构造

传统C++中，需要显示指明基类的构造函数来完成对基类的初始化；C++11利用关键字`using`引入继承构造函数

```c++
class SubBase :public Base {
public:
	using Base::Base;		// 继承构造
};

SubBase s(3);
```

## 显式虚函数重载

C++11引入`override` `final`两个关键字来防止意外重载虚函数

`override`关键字显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译

```c++
struct Base {
    virtual void foo(int);
};
struct SubClass: Base {
    virtual void foo(int) override; // 合法
    virtual void foo(float) override; // 非法, 父类没有此虚函数
};
```

`final`防止类被继续继承及终止虚函数继续重载

```c++
struct Base {
    virtual void foo() final;
};
struct SubClass1 final: Base {
}; // 合法
struct SubClass2 : SubClass1 {
}; // 非法, SubClass1 已 final
struct SubClass3: Base {
    void foo(); // 非法, foo 已 final
};
```

## 显式 采用/禁用 默认函数【C++11】

C++11使用`default` `delete`关键字来显式的声明采用或拒绝编译器生成的默认实现

````c++
class Magic {
public:
    Magic() = default; 		// 显式声明使用编译器生成的构造
    Magic& operator=(const Magic&) = delete; 	// 显式声明拒绝编译器生成赋值运算符
    Magic(int magic_number);
}
````

## 强类型枚举

C++11引入枚举类，并用`enum class`的语法进行声明

```c++
enum class new_enum :unsigned int {
	value1,
	value2,
	value3 = 100,
	value4 = 100
};

new_enum::value1;
```

若要获取枚举值的值，必须显式的进行类型转换，通过重载`<<`运算符来进行输出

```c++
#include <iostream>
template<typename T>
std::ostream& operator<<(
    typename std::enable_if<std::is_enum<T>::value, std::ostream>::type& stream, const T& e)
{
    return stream << static_cast<typename std::underlying_type<T>::type>(e);
}
```

## Lambda 表达式

Lambda表达式实际就是提供一个匿名函数的特性，基本语法：

```
[捕获列表](参数列表)mutable(可选) 异常属性 -> 返回类型 {
	// 函数体
}
```

lambda表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，通过捕获列表起到传递外部数据的作用

1. 值捕获

   值捕获的前提是变量可以拷贝，注意被捕获的变量是在lambda表达式被创建时拷贝，而非调用时才拷贝

   ```c++
   void lambda_value_capture() {
       int value = 1;
       auto copy_value = [value] {
           return value;			// 创建时就已经拷贝
       };
       value = 100;
       auto stored_value = copy_value();
       std::cout << "stored_value = " << stored_value << std::endl;
       // 这时, stored_value == 1, 而 value == 100.
   }
   ```

2. 引用捕获

   引用捕获保存的是引用，值会发生变化

   ```c++
   void lambda_reference_capture() {
       int value = 1;
       auto copy_value = [&value] {
           return value;
       };
       value = 100;
       auto stored_value = copy_value();
       std::cout << "stored_value = " << stored_value << std::endl;
       // 这时, stored_value == 100, value == 100.
       // 因为 copy_value 保存的是引用
   }
   ```

3. 隐式捕获

   由编译器隐式来完成捕获

   - [ ] 空捕获列表
   - [name1, name2, ...] 捕获一系列变量
   - [&] 引用捕获，让编译器自动推导捕获列表
   - [=] 值捕获

### 泛型 Lambda【C++14】

C++14开始，Lambda函数的形式参数可以使用`auto`关键字来产生意义上的泛型

```c++
auto add = [](auto x, auto y){
	return x + y;
}

add(1, 2);
```



